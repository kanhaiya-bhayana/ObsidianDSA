
"smart_completions:Untitled Chat 1748486447683-1748486533758": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"Hi"}]}]},"responses":[],"chat_model":null},"key":"Untitled Chat 1748486447683-1748486533758","thread_key":"Untitled Chat 1748486447683","stream":true,"user_message":"Hi","class_name":"SmartCompletion"},
"smart_completions:Untitled Chat 1748486565815-1748486565816": {"completion":{"request":{"messages":[{"role":"user","content":[{"type":"text","text":"‚îú‚îÄ‚îÄ Cohort/Module_03/\n‚îÇ   ‚îú‚îÄ‚îÄ 08_Linked_List_Basic_Problems/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Notes26052025.md\n‚îÇ   ‚îî‚îÄ‚îÄ 09_Stacks/\n‚îÇ       ‚îî‚îÄ‚îÄ Notes28052025.md\n‚îî‚îÄ‚îÄ Announcements.md\n\nAnnouncements.md\n```md\n### DSA Contest 1 => 15th May 2025 | Arrays, Bit Manipulation, Recursion, Math & Hashing\n### DSA Contest 2 => 18th June 2025 | Sorting, Searching, LinkedList, Stacks, Queues & Trees.\n##### Topics\n> Arrays, Bit Manipulation, Recursion, Math and Hashing\n### Quick Revision Notes\n[Arrays, Bit Manipulation, Recursion, Math & Hashing - HackMD](https://hackmd.io/Kh_c6edrTdWHVL7kTLS0CQ?view)\n---\n## Today\n- [ ]  Code by Shreyansh - 2 videos\n- [ ] ICICI Credit card bill \n- [x] Visa Apply\n- [ ] Inter Service Communication\n```\nCohort/Module_03/09_Stacks/Notes28052025.md\n```md\n## Stack\n##### Linear Data Structure | LIFO (Last In First Out) fashion\n> Access/Removal/Insertion of elements only from one end (Top).\n>Undo and Redo Operations\n>All operations in O(1) time\n```\nTC: O(1)\n```\n---\n### Implementation\n#### 1. Using Array\n```\nCohort/Module_03/08_Linked_List_Basic_Problems/Notes26052025.md\n```md\n# Check if the kth element present in the list or not.\n#LinkedList\n```java\npublic boolean chekcIfPresent(Node head, int val){\n\tNode curr = head;\n\twhile (curr != null) {\n\t\tif (curr.data == val) return true;\n\t\tcurr = curr.next;\n\t}\n\treturn false;\n}\n```\n# Insert at the kth Position\n#LinkedList \n```java\nclass Node {\n    int val;\n    Node next;\n    Node(int val) {\n        this.val = val;\n    }\n    Node(int val, Node next) {\n        this.val = val;\n        this.next = next;\n    }\n}\npublic Node insertAtPosition(Node head, int val, int k) {\n    if (k < 0) return head; // invalid position\n    if (k == 0) {\n        return new Node(val, head); // insert at head\n    }\n    Node curr = head;\n    int count = 0;\n    while (curr != null && count < k - 1) {\n        curr = curr.next;\n        count++;\n    }\n    if (curr == null) {\n        // k is beyond the length of the list\n        return head; // or throw exception\n    }\n    Node newNode = new Node(val, curr.next);\n    curr.next = newNode;\n    return head;\n}\n```\n>TC:  O(N) or O(k)\n>SC: O(1)\n# Delete the first occurrence of x in the list\n#LinkedList \n```java\nclass Node {\n    int val;\n    Node next;\n    Node(int val) {\n        this.val = val;\n    }\n    Node(int val, Node next) {\n        this.val = val;\n        this.next = next;\n    }\n}\npublic Node deleteFirstOccurrence(Node head, int x) {\n    if (head == null) return null;\n    // Case 1: The head contains x\n    if (head.val == x) {\n        return head.next;\n    }\n    // Traverse the list\n    Node curr = head;\n    while (curr.next != null) {\n        if (curr.next.val == x) {\n            // Found the node to delete\n            curr.next = curr.next.next;\n            break; // delete only the first occurrence\n        }\n        curr = curr.next;\n    }\n    return head;\n}\n```\n>TC: O(n)\n>SC: O(1)\n# Reverse a given Linked List\n#LinkedList \n```java\n// Function to reverse the linked list\npublic static ListNode reverseList(ListNode head) {\n\tListNode prev = null;\n\tListNode current = head;\n\t\n\twhile (current != null) {\n\t\tListNode nextNode = current.next; // store next node\n\t\tcurrent.next = prev;              // reverse the link\n\t\tprev = current;                   // move prev forward\n\t\tcurrent = nextNode;               // move current forward\n\t}\n\t\n\treturn prev; // new head of the reversed list\n}\n```\n### üìå Summary:\n|Complexity Type|Value|\n|---|---|\n|Time|O(n)|\n|Space|O(1)|\n---\n# Given a Linked List with random pointers. Create a deep copy of the list & return the Head of the copy list.\nHere‚Äôs a clear breakdown of the **steps/approach** for the **HashMap-based deep copy** of a linked list with `next` and `random` pointers:\n---\n### ‚úÖ **Step-by-Step Approach**\n---\n### üü© **Step 1: Clone all nodes and store mapping**\n- Traverse the original list.\n    \n- For each node, create a copy (with the same value).\n    \n- Store the mapping in a HashMap:\n    \n    ```java\n    map.put(originalNode, copiedNode);\n    ```\n    \n#### ‚úÖ Why?\nThis helps us later assign the `next` and `random` pointers for each copied node by referring to the map.\n---\n### üü© **Step 2: Assign next and random pointers**\n- Traverse the original list again.\n    \n- For each node:\n    \n    - Use the HashMap to assign:\n        \n        ```java\n        copy.next = map.get(original.next);\n        copy.random = map.get(original.random);\n        ```\n        \n#### ‚úÖ Why?\nThe map already contains all copied nodes. So we can safely assign the `.next` and `.random` by just looking up their references in the map.\n---\n### üü© **Step 3: Return the copied head**\n- Use `map.get(head)` to return the head of the copied list.\n    \n#### ‚úÖ Why?\nBecause this is the copy of the original list's head node.\n---\n### ‚úÖ Visual Example\nOriginal list:\n```\nA -> B -> C\n|    |    |\nv    v    v\nC    A    B\n```\nCopied list:\n```\nA' -> B' -> C'\n|     |     |\nv     v     v\nC'    A'    B'\n```\nWhere each `'` denotes a new node, and all `.next` and `.random` pointers are properly copied.\n---\n### üîÅ Summary\n|Step|Description|\n|---|---|\n|1|Clone nodes and map original ‚Üí copy|\n|2|Set `.next` and `.random` for copied nodes|\n|3|Return `map.get(head)` as the new head|\n---\n### ‚úÖ Java Code Using HashMap\n```java\nimport java.util.HashMap;\nclass Node {\n    int val;\n    Node next;\n    Node random;\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\npublic class DeepCopyRandomListWithMap {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        HashMap<Node, Node> map = new HashMap<>();\n        // Step 1: Create all the nodes and store the mapping from old -> new\n        Node curr = head;\n        while (curr != null) {\n            map.put(curr, new Node(curr.val));\n            curr = curr.next;\n        }\n        // Step 2: Assign next and random pointers using the map\n        curr = head;\n        while (curr != null) {\n            Node copy = map.get(curr);\n            copy.next = map.get(curr.next);      // safe even if curr.next is null\n            copy.random = map.get(curr.random);  // safe even if curr.random is null\n            curr = curr.next;\n        }\n        return map.get(head); // return the head of the new copied list\n    }\n}\n```\n---\n### üìä Time and Space Complexity\n|Type|Complexity|\n|---|---|\n|Time|`O(n)`|\n|Space|`O(n)`|\n```"},{"type":"text","text":"Hi There"},{"type":"text","text":"Hi There"}]}]},"responses":[],"chat_model":null},"key":"Untitled Chat 1748486565815-1748486565816","thread_key":"Untitled Chat 1748486565815","stream":true,"context_key":"1748486565816","class_name":"SmartCompletion","user_message":"Hi There"},