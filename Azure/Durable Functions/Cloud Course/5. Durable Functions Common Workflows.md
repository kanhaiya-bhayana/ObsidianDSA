Azure Durable Functions support a variety of common workflows, each designed to address different needs and scenarios. Here are some of the most common Durable Functions workflows, along with examples of how they might be used:
##### 1. Function Chaining Workflow
##### 2. Fan out/Fan in Workflow
##### 3. Human Interaction Workflow
##### 4. Monitor Workflow
##### 5. Durable Entities


Azure Durable Functions support a variety of common workflows, each designed to address different needs and scenarios. Here are some of the most common Durable Functions workflows, along with examples of how they might be used:

### 1. **Function Chaining**

**Description:**
- Function chaining is a pattern where one function calls another function in sequence. Each function performs a part of a larger task, and the output of one function becomes the input of the next.

**Example Scenario:**
- **Order Processing:** Process an order by validating it, charging the customer, and then sending a confirmation email. Each step is a separate function, and they execute in a specific sequence.

**Example Code:**
```csharp
[Function("OrderOrchestrator")]
public async Task<string> RunOrchestrator(
    [DurableTaskTrigger] IDurableOrchestrationContext context)
{
    var input = context.GetInput<OrderInput>();

    // Call the validation function
    bool isValid = await context.CallActivityAsync<bool>("ValidateOrder", input);

    if (!isValid)
    {
        throw new Exception("Order is not valid");
    }

    // Call the charge function
    await context.CallActivityAsync("ChargeCustomer", input);

    // Call the email function
    await context.CallActivityAsync("SendConfirmationEmail", input);

    return "Order processed successfully";
}
```

### 2. **Fan-Out/Fan-In**

**Description:**
- This pattern involves executing multiple functions in parallel (fan-out) and then aggregating their results (fan-in). It is useful for scenarios where you need to perform a task on multiple items concurrently and then aggregate the results.

**Example Scenario:**
- **Batch Processing:** Process a large set of data items in parallel (e.g., processing a list of images) and then aggregate the results into a final report.

**Example Code:**
```csharp
[Function("BatchProcessingOrchestrator")]
public async Task<string> RunOrchestrator(
    [DurableTaskTrigger] IDurableOrchestrationContext context)
{
    var inputs = context.GetInput<List<DataItem>>();

    // Fan-out: Process each data item in parallel
    var tasks = inputs.Select(item => context.CallActivityAsync("ProcessDataItem", item));
    await Task.WhenAll(tasks);

    // Fan-in: Aggregate results
    var results = await Task.WhenAll(tasks);
    var finalReport = AggregateResults(results);

    return finalReport;
}
```

### 3. **Human Interaction**

**Description:**
- In this pattern, the workflow pauses to wait for human input or an external event before continuing. It is useful for scenarios that require approval or interaction before proceeding.

**Example Scenario:**
- **Approval Workflow:** An expense report needs to be approved by a manager before processing. The workflow pauses until the manager approves the report.

**Example Code:**
```csharp
[Function("ApprovalWorkflowOrchestrator")]
public async Task<string> RunOrchestrator(
    [DurableTaskTrigger] IDurableOrchestrationContext context)
{
    var input = context.GetInput<ExpenseReport>();

    // Call the validation function
    bool isValid = await context.CallActivityAsync<bool>("ValidateExpenseReport", input);

    if (!isValid)
    {
        throw new Exception("Expense report is not valid");
    }

    // Wait for human approval
    var approvalStatus = await context.WaitForExternalEvent<string>("ApprovalEvent");

    if (approvalStatus == "Approved")
    {
        await context.CallActivityAsync("ProcessExpenseReport", input);
        return "Expense report approved and processed";
    }
    else
    {
        return "Expense report rejected";
    }
}
```

### 4. **Async HTTP API**

**Description:**
- This pattern uses Durable Functions to handle long-running HTTP requests by offloading the processing to a durable orchestration. The HTTP request triggers the orchestration, and the function returns a response with a status URL.

**Example Scenario:**
- **Long-Running Operations:** A request to process a large dataset or perform a time-consuming operation, where the client can check the status of the operation using a status URL.

**Example Code:**
```csharp
[Function("HttpStartFunction")]
public static async Task<IActionResult> HttpStartFunction(
    [HttpTrigger(AuthorizationLevel.Function, "post")] HttpRequest req,
    [DurableClient] IDurableOrchestrationClient starter)
{
    var requestBody = await new StreamReader(req.Body).ReadToEndAsync();
    var input = JsonConvert.DeserializeObject<ProcessInput>(requestBody);

    // Start the orchestration
    string instanceId = await starter.StartNewAsync("LongRunningOrchestrator", input);

    // Return status response
    return starter.CreateCheckStatusResponse(req, instanceId);
}
```

### 5. **Timer-Based Delays**

**Description:**
- This pattern involves pausing the workflow for a specific duration or until a particular time. It is useful for scenarios that require waiting before resuming processing.

**Example Scenario:**
- **Retry Logic:** Implementing a retry mechanism where the workflow waits for a specific period before retrying a failed operation.

**Example Code:**
```csharp
[Function("RetryOrchestrator")]
public async Task<string> RunOrchestrator(
    [DurableTaskTrigger] IDurableOrchestrationContext context)
{
    var input = context.GetInput<RetryInput>();

    try
    {
        // Perform the operation
        await context.CallActivityAsync("PerformOperation", input);
    }
    catch (Exception ex)
    {
        // Wait for a specific duration before retrying
        var delay = TimeSpan.FromMinutes(10);
        await context.CreateTimer(context.CurrentUtcDateTime.Add(delay), CancellationToken.None);

        // Retry the operation
        await context.CallActivityAsync("PerformOperation", input);
    }

    return "Operation completed";
}
```

### 6. **Durable Entities**

**Description:**
- Durable Entities are used to manage stateful entities with operations that can be performed over long periods. They provide a way to build stateful applications with reliable state management.

**Example Scenario:**
- **Shopping Cart:** Manage a shopping cart where items can be added or removed, and the cart's state is maintained reliably.

**Example Code:**
```csharp
[Function("ShoppingCartEntity")]
public static Task Run([EntityTrigger] IDurableEntityContext context)
{
    var cart = context.GetState<ShoppingCart>();

    switch (context.OperationName)
    {
        case "AddItem":
            cart.Add(context.GetInput<Item>());
            break;
        case "RemoveItem":
            cart.Remove(context.GetInput<Item>());
            break;
        case "GetCart":
            context.SetResult(cart);
            break;
    }

    context.SetState(cart);
    return Task.CompletedTask;
}
```

### Summary

Azure Durable Functions offer powerful patterns for building complex, stateful, and long-running workflows. Common workflows include:

- **Function Chaining:** Sequential execution of functions.
- **Fan-Out/Fan-In:** Parallel execution and aggregation of results.
- **Human Interaction:** Pausing for human input or external events.
- **Async HTTP API:** Handling long-running HTTP requests.
- **Timer-Based Delays:** Implementing delays or retry logic.
- **Durable Entities:** Managing stateful entities with reliable state management.

These patterns enable you to address a wide range of scenarios that require orchestration, state management, and fault tolerance in a serverless environment.